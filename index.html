<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Music Player with Recommendation</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 480px;
    margin: 0 auto;
    padding: 10px;
  }
  h1 {
    text-align: center;
  }
  #player {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 20px;
  }
  #controls {
    display: flex;
    justify-content: space-between;
  }
  button {
    flex: 1;
    margin: 0 2px;
    padding: 8px;
    font-size: 14px;
  }
  #likeBtn.liked {
    background: #4caf50;
    color: white;
  }
  #searchBar {
    width: 100%;
    padding: 6px;
    font-size: 16px;
    margin-bottom: 10px;
  }
  #musicList {
    max-height: 250px;
    overflow-y: auto;
    border: 1px solid #ddd;
    padding: 5px;
  }
  .music-item {
    padding: 6px;
    border-bottom: 1px solid #ccc;
    cursor: pointer;
  }
  .music-item:hover {
    background-color: #efefef;
  }
  #recommendations {
    margin-top: 20px;
  }
  #adminPanel {
    margin-top: 30px;
    border-top: 2px solid #333;
    padding-top: 10px;
  }
  #adminPanel h2 {
    margin-top: 0;
  }
  pre {
    background: #f9f9f9;
    padding: 10px;
    max-height: 200px;
    overflow-y: auto;
  }
  @media (max-width: 480px) {
    button {
      font-size: 12px;
      padding: 6px;
    }
  }
</style>
</head>
<body>

<h1>Music Player</h1>

<input type="text" id="searchBar" placeholder="Search by title or artist (e.g. Title or Artist or Title - Artist)" />

<div id="player">
  <audio id="audio" controls></audio>
  <div id="nowPlaying"></div>
  <div id="controls">
    <button id="backBtn">Back</button>
    <button id="playBtn">Play</button>
    <button id="stopBtn">Stop</button>
    <button id="nextBtn">Next</button>
    <button id="replayBtn">Replay</button>
    <button id="likeBtn">Like</button>
  </div>
</div>

<h3>Music List</h3>
<div id="musicList"></div>

<div id="recommendations">
  <h3>Recommended Music</h3>
  <div id="recommendList"></div>
</div>

<div id="adminPanel">
  <h2>Admin Panel - User Data (Admin)</h2>
  <button id="saveFileBtn">Save Data to server/info.json</button>
  <pre id="userDataDisplay"></pre>
</div>

<script>
(() => {
  const audio = document.getElementById('audio');
  const nowPlaying = document.getElementById('nowPlaying');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const nextBtn = document.getElementById('nextBtn');
  const backBtn = document.getElementById('backBtn');
  const replayBtn = document.getElementById('replayBtn');
  const likeBtn = document.getElementById('likeBtn');
  const musicListDiv = document.getElementById('musicList');
  const recommendListDiv = document.getElementById('recommendList');
  const searchBar = document.getElementById('searchBar');
  const userDataDisplay = document.getElementById('userDataDisplay');
  const saveFileBtn = document.getElementById('saveFileBtn');

  let musicData = [];
  let filteredMusic = [];
  let currentIndex = 0;

  // User data stored with tags and points
  // Structure:
  // userData = {
  //   likes: {tag1: points, tag2: points, ...},
  //   listens: {tag1: points, ...},
  //   searches: {tag1: points, ...}
  // }
  let userData = {
    likes: {},
    listens: {},
    searches: {},
  };

  // Load userData from localStorage if exists
  function loadUserData() {
    const saved = localStorage.getItem('musicUserData');
    if (saved) {
      try {
        userData = JSON.parse(saved);
      } catch {
        userData = {likes:{}, listens:{}, searches:{}};
      }
    }
  }
  loadUserData();

  // Save userData to localStorage
  function saveUserDataLocal() {
    localStorage.setItem('musicUserData', JSON.stringify(userData));
    updateAdminDisplay();
  }

  // Update admin panel display
  function updateAdminDisplay() {
    userDataDisplay.textContent = JSON.stringify(userData, null, 2);
  }

  // Save to file using File System Access API
  async function saveUserDataToFile() {
    try {
      const fileHandle = await window.showSaveFilePicker({
        suggestedName: 'info.json',
        types: [{
          description: 'JSON Files',
          accept: {'application/json': ['.json']},
        }],
      });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(userData, null, 2));
      await writable.close();
      alert('User data saved to info.json');
    } catch (e) {
      alert('Saving cancelled or failed: ' + e.message);
    }
  }

  saveFileBtn.onclick = saveUserDataToFile;

  // Fetch music data from service/music.json
  async function fetchMusicData() {
    try {
      const resp = await fetch('service/music.json');
      if (!resp.ok) throw new Error('Failed to load music data');
      musicData = await resp.json();
      filteredMusic = musicData;
      renderMusicList();
      loadTrack(0);
      renderRecommendations();
    } catch (e) {
      alert('Error loading music data: ' + e.message);
    }
  }

  // Render music list filtered
  function renderMusicList() {
    musicListDiv.innerHTML = '';
    filteredMusic.forEach((m, i) => {
      const div = document.createElement('div');
      div.className = 'music-item';
      div.textContent = `${m.title} - ${m.artist}`;
      div.onclick = () => {
        loadTrack(i);
        playAudio();
      };
      musicListDiv.appendChild(div);
    });
  }

  // Load track by index in filteredMusic
  function loadTrack(index) {
    if (index < 0 || index >= filteredMusic.length) return;
    currentIndex = index;
    const track = filteredMusic[index];
    audio.src = track.url;
    nowPlaying.textContent = `Now Playing: ${track.title} - ${track.artist}`;
    updateLikeButton();
  }

  // Play audio
  function playAudio() {
    audio.play();
  }

  // Stop audio
  function stopAudio() {
    audio.pause();
    audio.currentTime = 0;
  }

  // Replay current track
  function replayAudio() {
    audio.currentTime = 0;
    playAudio();
  }

  // Next track
  function nextTrack() {
    if (currentIndex < filteredMusic.length - 1) {
      loadTrack(currentIndex + 1);
      playAudio();
    }
  }

  // Back track
  function backTrack() {
    if (currentIndex > 0) {
      loadTrack(currentIndex - 1);
      playAudio();
    }
  }

  // Update Like button style based on like state
  function updateLikeButton() {
    const track = filteredMusic[currentIndex];
    const liked = getUserLikeForTrack(track);
    if (liked) {
      likeBtn.classList.add('liked');
      likeBtn.textContent = 'Liked';
    } else {
      likeBtn.classList.remove('liked');
      likeBtn.textContent = 'Like';
    }
  }

  // Get if user liked this track (simple: check if tags got points >0 in likes)
  function getUserLikeForTrack(track) {
    if (!track.tags) return false;
    return track.tags.some(tag => userData.likes[tag] > 0);
  }

  // Add points helper
  function addPoints(tagPoints, tag, points) {
    if (!tagPoints[tag]) tagPoints[tag] = 0;
    tagPoints[tag] += points;
  }

  // When user clicks Like button
  likeBtn.onclick = () => {
    const track = filteredMusic[currentIndex];
    if (!track.tags) return;
    const liked = getUserLikeForTrack(track);
    if (!liked) {
      // Add 0.5 to likes for all tags of this track
      track.tags.forEach(tag => addPoints(userData.likes, tag, 0.5));
    } else {
      // Unlike - remove 0.5 points from likes for those tags (not below zero)
      track.tags.forEach(tag => {
        if (userData.likes[tag]) {
          userData.likes[tag] -= 0.5;
          if (userData.likes[tag] < 0) userData.likes[tag] = 0;
        }
      });
    }
    saveUserDataLocal();
    updateLikeButton();
    renderRecommendations();
  };

  // When audio starts playing, add 0.2 to listens tags
  audio.onplay = () => {
    const track = filteredMusic[currentIndex];
    if (!track.tags) return;
    track.tags.forEach(tag => addPoints(userData.listens, tag, 0.2));
    saveUserDataLocal();
    renderRecommendations();
  };

  // Search function
  searchBar.addEventListener('input', () => {
    const query = searchBar.value.trim().toLowerCase();
    if (!query) {
      filteredMusic = musicData;
      renderMusicList();
      renderRecommendations();
      return;
    }

    // Parse search for title and artist (optional)
    // Format: "title - artist" or just one word (search in title or artist)
    let titlePart = null;
    let artistPart = null;
    if (query.includes('-')) {
      const parts = query.split('-').map(s => s.trim());
      titlePart = parts[0];
      artistPart = parts[1];
    } else {
      // If only one word, match title or artist
      titlePart = query;
      artistPart = null;
    }

    // Filter music based on rules:
    // If search by title only => get all tags from matching titles
    // If search by artist only => get tags from artist music only
    // If title and artist => get that music only

    filteredMusic = musicData.filter(m => {
      const t = m.title.toLowerCase();
      const a = m.artist.toLowerCase();
      if (titlePart && artistPart) {
        // Both required
        return t.includes(titlePart) && a.includes(artistPart);
      } else if (artistPart) {
        // artist only search
        return a.includes(artistPart);
      } else if (titlePart) {
        // title only search
        return t.includes(titlePart);
      }
      return false;
    });

    // Accumulate tags points for searches:
    // For title only: all tags of matching titles
    // For artist only: tags of music by that artist
    // For both: tags of matching music only
    const searchTagsPoints = {};

    filteredMusic.forEach(m => {
      if (m.tags) {
        m.tags.forEach(tag => {
          addPoints(searchTagsPoints, tag, 0.1);
        });
      }
    });

    // Add to userData.searches
    for (const [tag, pts] of Object.entries(searchTagsPoints)) {
      addPoints(userData.searches, tag, pts);
    }
    saveUserDataLocal();

    renderMusicList();
    renderRecommendations();
  });

  // Recommend music based on userData tags points
  function renderRecommendations() {
    // Calculate combined score per tag (likes * 1.0 + listens * 0.4 + searches * 0.2)
    // Adjust weights so likes are strongest
    const tagScores = {};

    function addTagScores(src, weight) {
      for (const tag in src) {
        if (!tagScores[tag]) tagScores[tag] = 0;
        tagScores[tag] += src[tag] * weight;
      }
    }
    addTagScores(userData.likes, 1.0);
    addTagScores(userData.listens, 0.4);
    addTagScores(userData.searches, 0.2);

    // Score each music based on sum of its tags' scores
    const scoredMusic = musicData.map(m => {
      let score = 0;
      if (m.tags) {
        m.tags.forEach(tag => {
          score += tagScores[tag] || 0;
        });
      }
      return {...m, score};
    });

    // Sort descending by score, filter out zero score
    const recommended = scoredMusic.filter(m => m.score > 0)
      .sort((a,b) => b.score - a.score)
      .slice(0, 10); // top 10

    recommendListDiv.innerHTML = '';
    if (recommended.length === 0) {
      recommendListDiv.textContent = 'No recommendations yet. Like or listen to music to get recommendations.';
      return;
    }

    recommended.forEach(m => {
      const div = document.createElement('div');
      div.className = 'music-item';
      div.textContent = `${m.title} - ${m.artist} (Score: ${m.score.toFixed(2)})`;
      div.onclick = () => {
        const idx = musicData.findIndex(x => x.title === m.title && x.artist === m.artist);
        if (idx !== -1) {
          filteredMusic = musicData;
          loadTrack(idx);
          playAudio();
          renderMusicList();
          renderRecommendations();
        }
      };
      recommendListDiv.appendChild(div);
    });
  }

  // Init player controls
  playBtn.onclick = () => {
    playAudio();
  };
  stopBtn.onclick = () => {
    stopAudio();
  };
  nextBtn.onclick = () => {
    nextTrack();
  };
  backBtn.onclick = () => {
    backTrack();
  };
  replayBtn.onclick = () => {
    replayAudio();
  };

  // When track ends, auto play next
  audio.onended = () => {
    nextTrack();
  };

  // Initial load music data
  fetchMusicData();

  // Show initial admin data
  updateAdminDisplay();
})();
</script>

</body>
</html>
